# 分布式测试基础

“做好分布式系统的测试比做一个分布式系统更难。”——PingCAP

## 理念

1. 谁负责测试？
2. 如何界定BUG？
3. 谁对BUG负责？
4. 如何提升系统质量？

#### 谁负责测试？

“Testing is owned by the entire team. It is a culture, not a process.”——PingCAP

测试工作需要整个团队去执行、参与，不仅仅是测试人员。

相对测试人员，开发人员更清楚系统的设计和实现，所以能更容易的构造测试去覆盖边界和各个代码分支。

#### 如何界定BUG？

"A software bug is an error, flaw, failure or fault in a computer program or system that causes it to produce an incorrect or unexpected result, or to behave in unintended ways."——维基百科

BUG是引起系统产生非预期结果或行为的错误、失败等等，比如一个计算程序：

* 输入1+1，返回是3而不是2
* 输入1+1，系统没有响应
* 输入1+1，系统应该在1毫秒内响应，结果在5毫秒后返回2

以上都应该是系统的BUG。

界定一个问题是否是BUG的标准应该是：

**结果是否和预期的一致，如果非一致，就是BUG。**

比如一段程序会运行缓慢，但是结果是正确的。如果这个运行速度不符合预期，那么就应当认为是BUG，需要优化。

比如一段程序虽然运行结果是正确的，但是运行期间占用了大量的内存。如果预期是不能使用这么多内存的，那么这段程序也存在BUG，需要修复。

预期结果是脱离程序存在的，无论程序如何实现，预期的结果是不变的，只要程序实现后的运行情况不满足预期结果，都认为是BUG。

#### 谁对BUG负责？

出现BUG后往往会有以下两种心态：

1. BUG出在别人的模块时，“这个BUG和我没关系，是他的模块”
2. BUG出现在自己的模块时则比较自责、羞愧

需要转变的观念是，BUG应该和测试一样，由整个团队去负责。理由如下：

1. 如果团队内没有完善的测试流程去保证代码质量，导致在测试时未能发现BUG，那么应由团队负责
2. 如果团队内有测试流程，比如完善的单元测试、Code Review等，依旧未能发现BUG，那么说明测试流程或者测试本身就存在问题，也不应由编码的同学单独承担责任

但这也不能成为开脱的理由，每个人还是需要对自己的代码质量负责。

摆正心态：

* 出现BUG后，追踪BUG产生的原因，从测试上去避免类似的BUG
* 不可能把系统的BUG清理干净，不断的从测试上去减小发生非预期内行为的可能性

#### 如何提升系统质量？

* 单元测试
* 自动化测试
* Code Review
* 让测试进入设计阶段

***单元测试***

对每个功能、模块都需要有对应的单元测试，测试正常流程、边界情况、异常情况等。

单元测试需要保证持续性：

1. 重构的代码，原单元测试无法覆盖的，需要重构单元测试
2. 任何新发现的BUG，都需要有单元测试去覆盖

***自动化测试***

1. 所有测试能自动化运行（一键运行给出结果；可以编排一些列测试）
2. 统计测试的代码覆盖率（提升代码覆盖率）

***Code Review***

Code Review应该被纳入到测试流程中：

1. 发现代码实现上的问题（一些明显的错误和不合理的地方）
2. 尽量统一团队内的编码风格

以尽量减小发生BUG的概率。

***让测试进入设计阶段***

这是非常重要的一点，这一点决定了系统实现之后能否有效的被测试。

在设计阶段就应该去考虑测试问题，甚至面向测试去设计。

比如功能依赖了外部的服务，那在设计阶段就应该考虑好测试时如何mock掉依赖的外部服务，以保证可以对功能进行单元测试。

## 测试方法

测试中最困难的部分是模拟各种异常的情况，比如磁盘异常、网络异常。

不可能真的构造一个不稳定的网络环境，或者使用故障的磁盘来验证程序，所以需要通过一些手段来模拟这些情况。

比如一个功能会有一个网络调用，那么可以通过程序模拟调用返回失败、调用没有返回、调用超时等各种情况——**模拟一切**。

### 错误注入

一种有效的模拟错误的方法是错误注入。

错误注入的原理是拦截要执行的方法，并返回需要的错误，类似于AOP(面向切面编程)。

比如网络调用，那么可以在调用方法的地方进行拦截，然后抛出网络异常来模拟网络不可用的情况。

*（错误注入仅适用在验证程序正确性上：通过错误注入模拟各种异常情况，验证程序在异常情况下的表现）*

错误注入的工具：

* libfiu - Fault injection in userspace
* FIT: Failure Injection Testing——Netfix
* OpenStack fault-injection library: https://pypi.python.org/pypi/os-faults/0.1.2
* CharybdeFS: A new fault-injecting file system for software testing



## 分布式系统测试工具介绍

### Jepsen

**Jepsen: Distributed Systems Safety Analysis**

Jepsen是验证分布式系统一致性的测试框架。

#### 原理

由一个控制节点（control node）和五个被控制节点（DB node）组成，控制节点向被控制节点发送指令，并在指令执行过程中模拟各种系统故障，最终验证结构是否符合一致性模型。

核心API：

* DB

DB 封装了所验证的分布式系统下载、部署、启动和关闭命令，核心函数由 setup 和 teardown 组成，在 TiDB 的 Jepsen 测试中，setup 负责下载 TiDB 并且依次启动 Placement Driver、TiKV 和 TiDB；teardown 负责关闭整个 TiDB 系统并且删除日志。

* Client

Client 封装了每一个测试所需要提供的客户，每个 client 提供两个接口：setup 和 invoke，setup 负责对 TiDB 进行连接，而 invoke 则包含了测试中 client 对 TiDB 调用的 sql 语句，具体语句依测试而定。

* Checker

Checker 用于对测试生成的历史进行验证，判断测试结果是否符合预期。

* Nemesis

Nemesis 用于对系统引入故障，比如常见的网络分区、网络延时、节点宕机。

* Generator

Generator 是 Jepsen 中的事件发生器，它将 Client 和 Nemesis 的操作交织在一起，为整个测试生成具体的执行语句。

引申：[一致性模型验证相关](https://pingcap.com/blog-linearizability-zh)





